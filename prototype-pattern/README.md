# 原型模式

如果一个类的有非常多的属性，层级还很深。每次构造起来，不管是直接构造还是用建造者模式，都要对太多属性进行复制，那么有没有一种好的方式让我们创建太的时候使用体验更好一点呢? 今天的文章里就给大家介绍一种设计模式，来解决这个问题。

这篇内容要说的是创造型设计模式里的原型模式，如果写过点 JS 代码的话，大家可能听说过原型链这么个东西，原型模式在 JavaScript 实现里确实广泛应用，它那个面向对象跟 Java、C++ 这些语言的面向对象的实现方式还不太一样，继承其实是通过原型克隆出来，在拷贝出来的原型的基础上再继续添加或者修改来实现的。



## 1. 概念

通过复制、拷贝或者叫克隆已有对象的方式来创建新对象的设计模式叫做原型模式，被拷贝的对象也被称作原型对象。



## 2. 理解

原型对象按照惯例，会暴露出一个 Clone 方法，给外部调用者一个机会来从自己这里“零成本”的克隆出一个新对象。

这里的“零成本”说的是，调用者啥都不用干，干等着，原型对象在 Clone 方法里自己克隆出自己，给到调用者，所以按照这个约定所有原型对象都要实现一个 Clone 方法。

```go
type Prototype interface {
    Clone() SpecificType
}
```



## 3. 类图

![图片](https://cdn.jsdelivr.net/gh/hedon954/mapStorage/img/640-20221221094230949.png)



## 4. 场景

使用原型模式的目的主要是为了节省创建对象所花费的时间和资源消耗，提升性能。

还有一点就是，比如全局配置对象这种也可以当成原型对象，如果不想让程序在运行时修改初始化好的原型对象，导致影响其他线程的程序执行的时候，也可以用原型模式快速拷贝出一份，再在副本上做运行时自定义修改。

当对象的创建成本比较大，并且同一个类的不同对象间差别不大时（大部分属性值相同），如果对象的属性值需要经过复杂的计算、排序，或者需要从网络、DB等这些慢IO中获取、亦或者或者属性值拥有很深的层级，这时就是原型模式发挥作用的地方了。

因为对象在内存中复制自己远比每次创建对象时重走一遍上面说的操作要来高效的多。



## 5. 拷贝方式

至于原型对象克隆自己的时候用的是深拷贝还是浅拷贝？可以先理解成是都用深拷贝，等完全掌握这种思想后，可以再根据实际情况，比如为了节省空间、以及减少编写克隆方法的复杂度时可以两者综合使用。

原型模式更多的是阐述一种编程模式，并没有限制我们用什么方式实现。比如下面这个深拷贝和浅拷贝结合使用的例子。

- [copy](./copy/copy.go)



## 6. Dom 树

下面是一个类似 DOM 树对象的例子，因为 DOM 对象往往层级会很深，那么要创建类似的 DOM 树的时候能让我们更好的理解原型模式的优势。

- [dom](./dom/dom.go)



## 7. 总结

原型模式的优点

- 某些时候克隆比直接 new 一个对象再逐属性赋值的过程更简洁高效，比如创建层级很深的对象的时候，克隆比直接用构造会方便很多。
- 可以使用深克隆方式保存对象的状态，可辅助实现撤销操作。

原型模式的缺点

- clone 方法位于类的内部，当对已有类进行改造的时候，需要修改代码，违背了开闭原则。
- 当实现深克隆时，需要编写较为复杂的代码，尤其当对象之间存在多重嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆。因此，深克隆、浅克隆需要运用得当。

在项目中使用原型模式时，可能需要在项目初始化时就把提供克隆能力的原型对象创建好，在多线程环境下，每个线程处理任务的时候，用到了相关对象，可以去原型对象那里拷贝。不过适合当作原型对象的数据并不多，所以原型模式在开发中的使用频率并不高，如果有机会做项目架构，可以适当考虑，确实需要再在项目中引入这种设计模式。



## 参考

- [Go学设计模式--原型模式的考查点和使用推荐](https://mp.weixin.qq.com/s?__biz=MzUzNTY5MzU2MA==&mid=2247496332&idx=1&sn=c28d336e9c9c964ffb78af922e0edc17&chksm=fa83231bcdf4aa0d0f7d6075fc1179a44153dc0a969c029b22d016a5ea510b1341821cc09e21&scene=178&cur_album_id=2531498848431669249#rd)

